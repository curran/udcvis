<h1>System Architecture</h1>
<p>Files on the Web -&gt; In-memory RDF Store -&gt; Visualization Algorithms

</p>
<h2>Files on the Web</h2>
<p>The files contain the Universal Data Cube (UDC).

</p>
<p>The UDC is a set of RDF triples describing instances of the following classes:

</p>
<ul>
<li>DataSet</li>
<li>DataCube</li>
<li>Dimension</li>
<li>Level</li>
<li>Member</li>
<li>Measure</li>
<li>Observation</li>
</ul>
<h2>In-Memory RDF Store</h2>
<p>An in-memory RDF store is used to store the UDC data in the client program.

</p>
<p>UDC clients are typically browser-based JavaScript and HTML5 applications.

</p>
<p>The in-memory RDF store is designed such that visualization algorithms can 
iterate in an incremental fashion through thir data query results.

</p>
<p>Clients using the in-memory RDF store can perform the following operations:

</p>
<ul>
<li>Insert an RDF triple</li>
<li><p>Query for values that match the &quot;?&quot; in following patterns:</p>
<ul>
<li>(subject, predicate, ?)</li>
<li>(?, predicate, object)</li>
</ul>
</li>
</ul>
<p>Query results are returned as an iterator that iterates over values in sorted
order. Therefore efficient algorithms for set union and intersection can be 
performed that themselves yield iterators that iteratively compute.

</p>
<p>Visualization algorithms can therefore perform complex SPARQL-like queries
against the in-memory RDF store which can be incrementally evaluated using
iterators. Because an iterator-based approach is taken, visualization 
painting algorithms can execute bit by bit each frame, maintaining
at least a 15 FPS framerate during interactions.

</p>
<h2>Visualization Algorithms</h2>
<p>In interactive information visualization systems, performance is key.<br>Ideally, the frame rate would never drop below 15 Frames Per Second.

</p>
<p>If one assumes a single threaded model of computation (as in JavaScript),
the requirement of continual interactive performance demands a mechanism of 
frame-by-frame execution of visualization painting algorithms.

</p>
<p>A visualization painting algorithm is an algorithm that iterates through data
query results and incrementally builds an interactive visualization by
defining marks.

</p>
<p>Data query results are results from queries on the in-memory RDF store.
To facilitate incremental visualization painting algorithms, these data query
results are exposed via an iterator-based API.

</p>
<p>Because the iterator-based API is used for incrementally building 
visualizations, one may think that the iterators must account in some way for
updates of the collection during iteration. This is not so, because a higher
level of the system should cause the visualization painting algorithm to
restart from scratch as soon as the new data is available.

</p>
<p>In other words, the iterators will always stop when the collections they are 
iterating over mutate (have elements added, removed, or changed).
In this case, the responsibility of notifying 

</p>
<h3>Marks and Layers</h3>
<p>A mark is a graphical representation of a set of Observations, as defined by 
Jaques Bertin in his book &quot;The Semiology of Graphics&quot;. Each mark contributes:

</p>
<ul>
<li>a polygon for the spatial index</li>
<li>a styled graphical mark drawn to the base bitmap layer</li>
</ul>
<p>We will assume that all visualizations in the UDC Visualization System will 
be displayed and interacted with via the following layers:

</p>
<ul>
<li>a spatial index layer, which improves performance of interactions,</li>
<li>a base layer that renders the visualization,</li>
<li>a selection layer that only draws selected elements,</li>
<li>a probe layer that only draws probed elements,</li>
<li>a tooltip layer that displays labels for probed elements.</li>
</ul>
<p>Separation into these layers mean that a system-wide API can handle the tasks
related to managing these layers and executing the following session-wide
interactions:

</p>
<ul>
<li>Brushed selection, which would cause only the selection layer to update</li>
<li>Brushed probing, which would cause the probe and tooltip layer to update.</li>
</ul>
<p>In addition to the visualizations themselves, there are the following:

</p>
<ul>
<li>The tiled pane user interface</li>
<li>The progress bar layer on top of the entire visualization system</li>
</ul>
<p>The tiled pane user interface defines the visible components in terms of a 
tree of horizontal and vertical containers (similar to Eclipse tabs).

</p>
<p>The progress bar layer displays pending operations and their status, such as:

</p>
<ul>
<li>Pending server requests</li>
<li>Ongoing data file parsing operations</li>
<li>Redrawing of visualizations</li>
<li>Frame rate information (only when it drops below 30)</li>
</ul>
<p>These indicators could also be represented with sound via the Web Audio API.
For example, a tone could sound while each request is made, and a drum could
sound whenever a parsing operation finished. Each operation made into sound 
would make the entire operation of the system audible, and therefore more
comprehensible.
</p>

